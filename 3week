Chapter 1. I/O와 디스크의 관계

# 오라클을 이해하기 위한 필수 키워드
	⁃	병렬 처리를 가능케 하고 높은 처리량을 실현한다
	⁃	응답을 중시한다
	⁃	커밋한 데이터는 지킨다

# 디스크의 I/O는 DBMS에게 필요한 것이긴 하지만 가능한 줄여야 하는 부분

# 시퀀셜은 '순서를 따라서'라는 의미의 순차를 뜻함, 시작점에서부터 마지막까지 중간 부분을 빠트리지 않고 전부 액세스하는 것입니다.

# 풀스캔(테이블의 모든 데이터를 읽어 오는 것을 의미)할 때 메모리에 데이터가 없다면 시퀀셜 액세스가 발생.

# 인덱스에는 색인할 때 사용하는 키 값(SQL문의 where절에 적는 조건의 값을 말함)과 그 키가 존재하고 있는 위치가 기록되어 있습니다
-> 인덱스 : 키값 + 키가 존재하는 위치

# 어드레스 (ROWID)

# 트리구조 -> 장점은 인덱스의 필요 없는 부분은 읽지 않고 끝난다는 것

# 랜덤 액세스
-> 필요한 부분이 디스크 위에 연속적으로 있는 경우는 거의 없음, 따라서 헤드를 움직여 가면서 띄엄띄엄 접근하게 됨
-> 이렇게 접근하는 방식을 랜덤 액세스라고 함
<-> 시퀀셜 액세스와 반대의 의미



Chapter 2. 오라클의 여러 프로세스

# 데이터베이스 사용 X -> 개개의 프로세스가 자신이 가진 변수(데이터)를 처리하는 것이 일반적

# 데이터베이스는 여러 프로세스나 사용자가 하나의 데이터베이스(데이터집합)에 접근함

# 데이터베이스에는 기본적으로 데이터를 중복으로 보관하지 않으며, 보관해서도 안됨

# 프로세스와 스레드
	⁃	프로세스 : 실행상태에 있는 프로그램을 의미함, 실행상태이기 때문에 메모리나 자원을 가지고 있음
	⁃	스레드 : 프로세스 내에 존재하는 실행단위, 하나의 프로세스 안에서 처리를 병렬로 하고 싶을 때 사용함.

# 엑셀, DBMS의 차이
	⁃	엑셀은 하나의 PC에 작동, 단일사용자가 사용하는 것
	⁃	DBMS는 여러 사용자나 애플리케이션이 데이터를 공유한다는 전제로 만들어져 있어 여러 사용자가 동시에 데이터를 검색, 갱신가능, 락 장치 보유

# 백그라운드 프로세스의 일
	⁃	서버 프로세스 : SQL문을 처리하는 프로세스
	⁃	백그라운드 프로세스 : 주로 서버 프로세스를 도와주는 프로세스로 구성되어 있음


# DB에서 수행하는 주요 처리
￼1: SQL 문의 수신
2: SQL 문의 파싱
3: 데이터 읽기
4: 데이터 기록
5: SQL 문의 결과 회신
6: 로그 기록
7: 각종 정리
8: 로그 보관
-> SQL문을 처리하는데 필요한 작업 : 1,2,3,5
-> 파싱이라는 작업을 하지 않으면 어떤 테이블에 접근해야 하는지조차 알 수 없음
-> DBWR(데이터베이스 라이터) : 디스크에 데이터를 기록하는 일

# 원칙적으로 각 프로세스의 역할 분담을 나누어보면, SQL의 결과를 회신하는 데 필요한 것은 서버 프로세스가 수행하고, 그 이외의 것은 백그라운드 프로세서가 수행한다

# 섀도 프로세스, 포그라운드 프로세스

Chatper 3. 캐시와 공유 메모리

# 캐시가 필요한 이유
디스크가 동작하는 것은 매우 느림-> 가능한 디스크에서 처리하지 않게 하려고 '캐시'라고 불리는 기술을 사용

# 캐시란?
버퍼 캐시에 데이터가 적재되어 잇지 않을 때는 속도가 느린 디스크에서 데이터를 꺼내올 수밖에 없으므로 그만큼 SQL의 처리가 늦어짐

# 데이터는 블록 단위로 관리
오라클은 블록이라고 단위로 데이터를 관리

# 캐시의 사용으로 인덱스 검색을 효율적으로 
	⁃	테이블뿐만이 아니라 인덱스도 블록으로 구성되어 있음.
	⁃	인덱스를 한 블록에 보관할 수 없을 때는 여러 개의 블로으로 구성함


# 프로세스는 캐시를 공유한다
	⁃	기본적으로 다른 프로세스의 메모리를 보는 것은 불가능
	⁃	데이터에 손상을 입히지 않도록 OS가 보호하고 잇기 때문
	⁃	DBMS입장에서는 불편하기에 OS의 기능 중 특수한 메모리 기능이 제공됨 -> 공유 메모리
	⁃	공유 메모리를 사용하면 자신의 메모리 영역에 기록했던 데이터를 다른 프로세스에서도 즉시 볼 수 있음
	⁃	실제 메모리는 한개다!!
	⁃	SGA (System Global Area) : 공유메모리
	⁃	PGA (Program Global Area) : 공유하지 않는 메모리 일부

# DB_CACHE_SIZE : 버퍼 캐시의 크기를 결정하는 파라미터

# 버퍼캐시를 정리하는 LRU 알고리즘
	⁃	LRU (Least Recenty Used) : 최근에 사용하지 않은 데이터부터 캐시 아웃(버린다)하는 알고리즘
	⁃	오라클의 서버 프로세스는 변경한 데이터도 캐시에 둠
	⁃	DBWR은 디스크에 부하를 주지 않도록 조심하며 정기적으로 변경한 데이터를 디스크에 보존함
	⁃	오라클은 큰 테이블이라고 판단하며 풀 스캔한 것을 버퍼 캐시에 오랜시간 보관하지 않도록 하고 있음
	⁃	풀 스캔 했을 때의 데이터는 버퍼 캐시에 적재되지 않는다(일반적으로)

# 오라클뿐만이 아닌 OS나 스토리지에 대해서도 생각하자
'스토리지의 캐시' -> 스토리지에서 데이터를 읽어 오는 것이 빨라지지만, 그것뿐만이 아니라 기록하는 것도 빨라짐. 그 이유는 원래라면 디스크에 기록해야 하는 것을 캐시에 기록하는 것만으로도 OS 관점에서의 I/O를 종료할 수 있기 때문

# OS의 버퍼 캐시와 가상 메모리의 차이
	⁃	버퍼캐시, 가상메모리 -> 오라클의 버퍼 캐시
	⁃	페이징은 물리 메모리와 디스크 사이에서 주고 받는 블록을 뜻함.
	⁃	물리 메모리에서 디스크에 페이지를 기록하는 것을 페이지 아웃, 디스크에서 물리 메모리에 페이지를 읽어오는 것을 페이지 인이라고 함
	⁃	


￼
