04. 테이블 Random 액세스 부하
	•	Random 액세스가 가장 큰 부하 요인으로 작용하는 원인?

	1.	인덱스 ROWID에 의한 테이블 액세스
	-> 쿼리에서 참조되는 컬럼이 인덱스에 모두 포함되는 경우가 아니라면 인덱스 스캔 이후 테이블 Random 액세스가 일어난다.

   #물리적? 논리적?
	1) rowid 는 흔히 ‘물리적 주소정보’로 일컬어짐.
	2) rowid = 오브젝트번호, 데이터파일번호, 블록 번호
	3) 논리적 주소정보라곡 표현되기도 함.

    # 메인메모리 DB(MMDB)와의 비교
	1) 메인 메모리 DB에서 인스턴스를 기동하면 디스크에 저장된 데이터를 버퍼 캐시로 로딩하고 이어서 인덱스를 실시간으로 만듬
	2) 이때 인덱스를 메모리상의 주소정보, 즉 포인터를 담는다 (오라클은 디스크 상의 주소정보를 담는다)
	3)오라클은 테이블 블록이 수시로 버퍼 캐시에서 밀려났다가 다시 ㅐ싱되며, 그때마다 다른 공간에 캐싱되기 때문에 인덱스에서 직접 포인터로 연결할 수 없는 구조, 대신 디스크 상의 블록 위치 정보, 즉 DBA를 해시 키 값으로 삼아 해싱 알고리즘을 통해 버퍼 블록을 찾음. 매번 위치가 달라지더라도 캐싱되는 해시버킷만큼은 고정적.

  # 인덱스 rowid에 의한 테이블 액세스 구조
	1) 버퍼 Pinning 기법을 사용하지만 반복적으로 읽힐 가능성이 큰 블록에 대해서만 일부 적용하고 있음.

	2.	인덱스 클러스터링 팩터

   #군집성 계수(=데이터가 모여 있는 정도)
	1) 클러스터링 팩터 => 군집성 계수
	2) 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도
	3) CF가 좋은 컬럼에 생성한 인덱스는 검색 효율이 매우 좋음
	4) 물리적으로 근접해 있으면 흩어져 있을때보다 데이터를 찾는 속도가 빨라짐

   #클러스터링 팩터 조회
	1) CF는 데이터가 모여 있는 정도를 의미
	2) 클러스터링 팩터 수치가 테이블 블로에 가까울수록 데이터가 잘 정렬돼 있음을 의미, 레코드 개수에 가까울수록 흩어져 있음을 의미

   #클러스터링 팩터 계산로직
	1) counter 변수를 하나 선언한다
	2) 인덱스 리프 블록을 처음부터 끝까지 스캔하면서 인덱스 rowid로부터 블록 번호를 취한다
	3) 현재 읽고 있는 인덱스 레코드의 블록 번호가 바로 직전에 읽은 레코드의 블록 번화와 다를 때마다 counter 변수 값을 1씩 증가시킴
	4) 스캔을 완료하고서, 최종 counter	변수값을 클러스터링 팩터로서 인덱스 통계에 저장한다

   #인덱스를 이용한 테이블 액세스 비용 계산 공식 
비용 = blevel +									— 인덱스 수직적 탐색비용
		(리프 블록 수 x 유효 인덱스 선택도) +.     — 인덱스 수평적 탐색비용
		(클러스터링 팩터 x 유효 테이블 선택도)    — 테이블 Random
													액세스 비용

> blevel : 리프 블록에 도달하기 전 읽게 될 브랜치 블록 개수
> 유효 인덱스 선택도 : 전체 인덱스 레코드 중에서 조건절을 만족하는 레코드를 찾기 위해 스캔할 것으로 예상되는 비율(%)
> 유효 테이블 선택도 : 전체 레코드 중에서 인덱스 스캔을 완료하고서 최종적으로 테이블을 방문할 것으로 예상되는 비율(%)

   #클러스터링 팩터와 물리적 I/O
	1) 인덱스 CF 가 좋다 = 인덱스 정렬 순서와 테이블 정렬 순서가 서로 비슷하다는 것
	2) 인덱스 레코드는 항상 100프로 정렬된 상태를 유지
	3) 테이블 레코드도 이와 비슷한 정렬순서를 갖는다면 값이 같은 레코드들이 서로 군집해 있음을 뜻함
	4) 궁극적으로 물리적인 디스크 I/O 횟수를 감소시키는 효과
	
   #클러스터링 팩터와 논리적 I/O
	1) 인덱스 CF는 인덱스를 경유해 테이블 전체 로우을 액세스할 때 읽을 것으로 예상되는 논리적인 블록 개수를 의미

   #버퍼 Pinning에 의한 논리적 I/O 감소 원리
	1) 인덱스 CF에 따라 논리적인 블록 I/O개수가 이처럼 심하게 차이 나는 이유는 인덱스를 통해 액세스되는 하나의 테이블 버퍼 블록을 Pinning 하기 때문
	2) 방금 액셋한 버퍼에 대한 Pin을 즉각 해제하지 않고 데이터베이스 Call 내에서 계속 유지하는 기능
	3) 연속되는 인덱스 레코드가 같은 블록을 가리킨다면, 래치 획득 과정을 생략하고 버퍼를 Pin한 상태에서 읽기 때문에 논리적인 블록 읽기 횟수가 증가하지 않는다


	3.	인덱스 손익분기점
	-> Index Range Scan에 의한 테이블 액세스가 Table Full Scan 보다 느려지는 지점을 흔히 ‘손익분기점’이라고 부름
	
   #인덱스에 의한 액세스가 Full Table Scan 보다 더 느려지게 만드는 요인
	1) 인덱스 rowid에 의한 테이블 액세스는 Random 액세스인 반면, Full Table Scan 은 Sequential 액세스 방식으로 이루어짐
	2) 디스크 I/O시 인덱스 rowid에 의한 테이블 액세스는 Single Block Read 방식을 사용하는 반면, Full Table Scan 은 Multiblock Read 방식을 사용

	-> 손익분기점은 인덱스가 항상 좋을 수 없음을 설명하려고 도입한 개념일 분, 높이기 위해 어떤 조치를 취하라는 것은 아니다. 즉, 테이블 스캔이 항상 나쁜 것은 아니며 바꿔 말해, 인덱스 스캔이 항상 좋은 것도 아니라는 사실을 인식시키기 위함

   #손익분기점을 극복하기 위한 기능들
	1) 선택도가 높은 인덱스는 효용가치가 낮지만 대용량 테이블을 Full Scan하는 것 역시 비효율이 큼
	-> 첫번째 : IOT로서, 테이블을 인덱스 구조로 생성하는 것을 말함. 테이블 자체가 인덱스 구조이므로 항상 정렬된 상태를 유지, 인덱스 리프 ㅂ르록이 곧 데이터 블록이어서 인덱스를 수직 탐색한 다음에 테이블 레코드를 읽기 위한 추가적인 Random 액세스가 불필요.
	-> 두번째 : 클러스터 테이블, 키 값이 같은 레코드는 같은 블록에 모이도록 저장하기 때문에 클러스터 인덱스를 이용할 때는 테이블 Random 액세스각 키 값별로 한 번씩만 발생. 클러스터에 도달해서는 Sequential 방식으로 스캔하기 때문에 넓은 범위를 읽더라도 비효율이 없음

	-> 세번째 : 파티셔닝, 대량 범위 조건으로 자주 사용되는 컬럼 기준으로 테이블을 파티셔닝한다면 Full Table Scan 하더라도 일부 파티션만 읽고 멈추도록 할 수 있음



05. 테이블 Random 액세스 최소화 튜닝

	1.	인덱스 컬럼 추가
	인덱스를 추가해 나가다 보면 테이블마다 인덱스가 수십 개씩 달려 배보다 배꼽이 더 커지게 됨
	-> 기존 인덱스에 sal 컬럼을 추가하는 것만으로 큰 효과를 거둘 수 있음

	2.	PK 인덱스에 컬럼 추가
	Non-Unique 인덱스를 이용해 PK 제약을 설정한다면 인덱스 개수를 줄일 수 있음

	3.	컬럼 추가에 따른 클러스터링 팩터 변화
	변별력이 좋은 다른 컬럼을 추가할 때는 클러스터링 팩터 변화에 주의를 기울여야 함

	4.	인덱스만 읽고 처리
	테이블 액세스가 발생하지 않도록 모든 필요한 컬럼을 인덱스에 포함시키는 방법을 고려해 볼 수 있음 MS-SQL Server에서 사용하는 용어 ‘Covered 인덱스’, 인덱스만 읽고 처리하는 쿼리 ‘Covered 쿼리

	5.	버퍼 Pinning 효과 활용
	오라클에 경우 한번 입력된 테이블 레코드는 절대 rowid가 바뀌지 않음, 즉 레코드 이동이 발생하지 않음. 따라서 미리 알고 있던 테이블 rowid 값을 이용해 레코드를 조회하는 것이 가능하다

	6.	수동으로 클러스터링 팩터 높이기
	-> 가장 자주 사용되는 인덱스를 기준으로 삼음
	-> 다른 인덱스를 사용하는 중요한 쿼리 성능에 나쁜 영향을 주지 않는지 반드시 체크해 봐야함

